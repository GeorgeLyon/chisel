find_package(Java REQUIRED)
find_package(JNI REQUIRED)
include(UseJava)

# I'm no CMake expert and this is the best method I was able to come up with for building a JAR from the CMake flow.
# There are 4 interesting targets:
# - CircelJNIUnbundled and CircelJNIHeaders: These use the built-in CMake capability to create a JAR file and generate JNI headers to implement it.
# - CircelJNINative: This is a standard C++ library which has access to the headers generated by the two targets above and is responsible for implementing the methods defined in those headers.
# - CircelJNI: A custom target which copies the original JAR created by CircelJNIUnbundled, and creates a new JAR with the library compiled by CircelJNINative added as a resource. CMake didn't love when I tried to update the CircelJNIUnbundled jar in-place, hence the separate output JAR. By adding the native library as a resource, we are able to use the vendored NativeUtils.java to load that library at runtime without having to rely on `java.library.path` which we may not be able to modify for all use cases.
# This approach also lays the groundwork for packaging multiple architectures in the JAR and dynamically selecting the correct one at runtime.

add_jar(CircelJNIUnbundled
    NativeUtils.java
    IRBuilder.java
    GENERATE_NATIVE_HEADERS CircelJNIHeaders)
add_circt_library(CircelJNINative
    SHARED
    IRBuilder.cpp
    
    LINK_LIBS PRIVATE
    CIRCTFirtool
    MLIRBindingsSupport
    )
target_link_libraries(CircelJNINative PRIVATE CircelJNIHeaders)
target_include_directories(CircelJNINative PRIVATE ${JNI_INCLUDE_DIRS})
add_custom_target(CircelJNI
    COMMAND cp $<TARGET_PROPERTY:CircelJNIUnbundled,JAR_FILE> CircelJNI.jar
    COMMAND ${Java_JAR_EXECUTABLE} --update --file CircelJNI.jar -C $<TARGET_FILE_DIR:CircelJNINative> $<TARGET_FILE_NAME:CircelJNINative>
    DEPENDS 
        CircelJNIUnbundled
        CircelJNINative)
